# 实验报告

学号1 姓名1 学号2 姓名2 学号3 姓名3
## 说明
问题回答部分由每个组员自己编写，剩余的部分由小组成员共同编写。
## 问题回答

## 实验设计
### 每个节点的`Visit`方法设计
1. `InitVal`

2. `FuncDef`

3. `FuncFParamList`

4. `FuncParam`

5. `VarDef`

   ​	这一部分处理变量的初始化。 我们分层次进行这一节点的设计。 首先在SysYFIR中， 全局变量和局部变量使用不同的分配空间的方式和初始化的方式， 所以我们先讨论是否是全局变量。 然后对于每一个变量， 我们讨论其是不是数组， 是否初始化以及其变量类型。 根据不同的变量类型分别完成对不同变量的空间分配和初始化。

6. `LVal`

   ​	这一部分处理表达式(expr)中出现的标识符以及赋值函数中出现的左值标识符。 因为在赋值函数Assign中， 访问target(LVal)节点期望得到的信息是变量的指针(便于存储)， 而在普通的表达式节点(expr)中期望得到的是变量的值， 因此我们需要另设变量告诉LVal我们需要的是什么值。 我们设置全局布尔型变量 LVal_retValue和LVal_retPtr， 用来告诉LVal我们需要获取的是指针还是数值， 在每一次访问expr节点前， 我们都对全局变量进行设置， 以保证两个变量其一为0。

   ​	值得注意的是， 我们处理数组时， 由于函数可以接收数组指针作为变量， 所以除了数组类型ArrayType以外， 我们还有可能接收到指针类型PointerType， 对这两种类型的处理在task2中进行过讨论。 PointerType我们只需要设置偏移量， 而ArrayType我们需要前置一个CONST_INT(0) 来进入数组第一维， 再利用其偏移量得到我们想要的数组下标。

7. `AssignStmt`

   ​	这一部分处理赋值语句。 由于LVal帮我们做了大部分内容， 所以这一部分设计相对简单。 需要注意的点是不同类型的值之间进行相互赋值时要考虑到类型的转换。SysYF中赋值语句右侧是不出现布尔型表达式的， 即使考虑初始化， 等号右侧也不会有布尔表达式， 所以我们相应也没有编写这种情况对应的代码。

8. `Literal`

   ​	这一部分处理字面量。 这一部分代码由框架给出， 我们不作赘述。 由于组员使用全局变量进行节点间值的传递， 因此我们将visitee的返回方式改为全局变量返回。

   ​	但是有一点需要注意的是， 对于定义成浮点类型的整数， 如 fload c = 4;， 字面量只能读出4为CONST_INT(4)， 需要vardef进行自行的判断类型和赋值的类型是否匹配， 如果不匹配， 必须进行类型的更改。

9. `ReturnStmt`

   ​	这一部分处理函数返回。 部分代码已给出， 但我们还是作了较多的修改。 为了main函数默认返回0， 我们引入新的全局变量告诉funcdef 当前函数是否具有了返回声明。 然后我们作统一的返回出口， 所有return语句跳到统一的返回出口进行返回。

10. `BlockStmt`

    ​	这一部分处理函数体等(包括if， while， {}的函数体)。 代码框架已给出(我记得好像是给的)， 我们没有作修改处理。

11. `EmptyStmt`
    直接置空不管即可，因为不会产生中间代码。

12. `ExprStmt`
    递归访问其中的`exp`即可。

13. `UnaryCondExpr`

14. `BinaryCondExpr`

15. `BinaryExpr`

16. `UnaryExpr`

17. `FuncCallStmt`

18. `IfStmt`

19. `WhileStmt`

20. `BreakStmt`

21. `ContinueStmt`
### Add Others If You Need
## 实验难点及解决方案

## 实验总结

## 实验反馈

## 组间交流
