# 实验报告

PB22111631 郭泽 PB22071456 储溦 PB22111627 殷一鸣
## 说明
问题回答部分由每个组员自己编写，剩余的部分由小组成员共同编写。
## 问题回答

## 实验设计
### 每个节点的`Visit`方法设计
1. `InitVal`

    首先定义一个InitItem的结构体，主要处理初始化项的两种情况（初始化项为单一值
->value_flag=true/初始化项为一个复合类型->expr为空，list存嵌套的初始化项列表），注意在initval开始时创建一个now_init_item来存储当前初始化项，最后将其赋给last_init_item全局变量作为最近生成的初始化项

2. `FuncDef`
    这一部分处理函数的定义，首先，需要在 IRBuilder 中为函数定义相关的标志变量进行初始化, 然后，在函数定义过程中通过 get_type 函数获取函数的返回类型。如果函数返回的是非 void  型，后续需要为该返回类型分配内存。如果函数有参数列表，需要进一步解析每个参数的类型  称。参数的类型可以是基本数据类型或者数组类型。如果是数组类型，则需要将其转换为指  型。函数类型由返回类型和参数类型列表构成。我们使用 FunctionType::create 来构造函类型，并用它创建一个 Function 对象。创建完成后，将该函数存入当前作用域，标记为当前函数 (CurrentFunction)。之后，需要进入函数作用域并创建基本块。接下来处理函数体的生成，通常包括循环、条件判断和其它语句。我们通过递归调用 node.body->accept(*this) 来处理函数体。如果在函数体内没有显式的 return 语句，我们会根据函数的返回类型补充一个默认返回值（对于 main 函数，我们补充返回值 0；对于其它非 void 类型的函数，我们补充返回值；对于 void 类型的函数，我们直接生成 void ret。）注意最后需要恢复 retAlloc 的值（retAlloc = tmpAlloc）

3. `FuncFParamList`
    遍历访问节点的参数即可
4. `FuncParam`
   
    首先获取函数参数的类型，为了处理将一维数组指针作为参数，还要加上是否为数组类型的判断，若是，则通过PointerType::get(paramType)将其更新为指针类型。最后将将参数类型和参数名存入参数列表即可。

5. `VarDef`

   这一部分处理变量的初始化。 我们分层次进行这一节点的设计。 首先在`SysYFIR`中， 全局变量和局部变量使用不同的分配空间的方式和初始化的方式， 所以我们先讨论是否是全局变量。 然后对于每一个变量， 我们讨论其是不是数组， 是否初始化以及其变量类型。 根据不同的变量类型分别完成对不同变量的空间分配和初始化。

6. `LVal`

   ​	这一部分处理表达式(`expr`)中出现的标识符以及赋值函数中出现的左值标识符。 因为在赋值函数`Assign`中， 访问`target(LVal)`节点期望得到的信息是变量的指针(便于存储)， 而在普通的表达式节点(`expr`)中期望得到的是变量的值， 因此我们需要另设变量告诉`LVal`我们需要的是什么值。 我们设置全局布尔型变量 `LVal_retValue`和`LVal_retPtr`， 用来告诉`LVal`我们需要获取的是指针还是数值， 在每一次访问`expr`节点前， 我们都对全局变量进行设置， 以保证两个变量其一为0。

   ​	值得注意的是， 我们处理数组时， 由于函数可以接收数组指针作为变量， 所以除了数组类型`ArrayType`以外， 我们还有可能接收到指针类型`PointerType`， 对这两种类型的处理在`task2`中进行过讨论。 `PointerType`我们只需要设置偏移量， 而`ArrayType`我们需要前置一个`CONST_INT(0)` 来进入数组第一维， 再利用其偏移量得到我们想要的数组下标。

7. `AssignStmt`

   ​	这一部分处理赋值语句。 由于`LVal`帮我们做了大部分内容， 所以这一部分设计相对简单。 需要注意的点是不同类型的值之间进行相互赋值时要考虑到类型的转换。`SysYF`中赋值语句右侧是不出现布尔型表达式的， 即使考虑初始化， 等号右侧也不会有布尔表达式， 所以我们相应也没有编写这种情况对应的代码。

8. `Literal`

   ​	这一部分处理字面量。 这一部分代码由框架给出， 我们不作赘述。 由于组员使用全局变量进行节点间值的传递， 因此我们将`visitee`的返回方式改为全局变量返回。

   ​	但是有一点需要注意的是， 对于定义成浮点类型的整数， 如 `fload c = 4`;， 字面量只能读出4为`CONST_INT(4)`， 需要`vardef`进行自行的判断类型和赋值的类型是否匹配， 如果不匹配， 必须进行类型的更改。

9. `ReturnStmt`

   ​	这一部分处理函数返回。 部分代码已给出， 但我们还是作了较多的修改。 为了`main`函数默认返回0， 我们引入新的全局变量告诉`funcdef` 当前函数是否具有了返回声明。 然后我们作统一的返回出口， 所有`return`语句跳到统一的返回出口进行返回。

10. `BlockStmt`

    ​	这一部分处理函数体等(包括`if`， `while`， `{}`的函数体)。 代码框架已给出(我记得好像是给的)， 我们没有作修改处理。

11. `EmptyStmt`
    直接置空不管即可，因为不会产生中间代码。

12. `ExprStmt`
    递归访问其中的`exp`即可，不需要发射指令，会在具体的表达式节点发送。

13. `UnaryCondExpr`

    该函数负责为单目条件运算符 `NOT` 生成 `IR` 指令。在实现中，通过暂存当前的 `TrueBB` 和 `FalseBB`（表示条件为真或假的基本块）状态后，将两者交换，以反映 `NOT` 的逻辑反转特性。递归访问子表达式后，根据其结果类型（如 `INT1_T`, `INT32_T`, 或 `FLOAT_T`），生成对应的比较指令(注意这里是`eq`指令而不是`ne`指令)，判断子表达式值是否为零，从而实现逻辑取反。最后，恢复原先的 `TrueBB` 和 `FalseBB` 状态，以保证递归访问对全局状态的影响被消除。这种处理方式既保证了短路计算的正确性，也维护了全局环境的完整性。

14. `BinaryCondExpr`

    该函数实现了对二目条件表达式的 `IR` 生成逻辑，支持逻辑运算符（`AND` 和 `OR`）以及关系运算符（如等于、不等于、大于等于等）的处理。对于逻辑运算符 `AND` 和 `OR`，函数实现了短路计算机制。首先对于`OR`，如果左操作数为真，可以直接跳转到整体条件的 `TrueBB`（即全局的`TrueBB`），无需计算右操作数；否则进入右操作数处理分支。函数通过为左操作数创建一个 `RightBB` 局部基本块表示右操作数的入口点，同时保存并恢复 `FalseBB`（因为对于左操作数而言，其错误分支不是全局整个条件表达式的错误分支），以确保逻辑正确性。同样，对于 `AND`，如果左操作数为假，可以直接跳转到整体条件的 `FalseBB`；否则进入右操作数处理分支。类似地，为右操作数创建 `RightBB` 局部基本块，保存并恢复 `TrueBB`。在访问操作数后，函数将值统一转换为布尔类型 (`INT1_T`) 并生成相应的条件跳转指令。对于关系运算符，函数会依次处理左右操作数，并通过类型转换确保两者类型一致（可能涉及 `INT1_T、INT32_T、FLOAT_T` 等）。然后根据运算符类型（如`EQ`、`NEQ`、`GT` 等）生成对应的比较指令，比较结果被更新给 `latest_value` ，用于表示全局最近处理的表达式的值，以便后续的控制流读取处理。

15. `BinaryExpr`

    这里分为两种情况，因为我们实现了对常量的编译优化。

    - 左右操作数都是常量（通过`std::dynamic_pointer_cast<ConstantFloat>(value_temp)`来判别）：只需要根据常量类型经过适当类型转换后，产生常量赋值给`latest_value`即可，不需要发射指令。

    - 存在变量操作数：需要经过类型转换后，根据`node.op`发射对应的指令，并返回给`latest_value`。

16. `UnaryExpr`

    这里可能出现的算符是`+`和`-`，代表正和负，我们也分成了常量和便量两种情况。
    - 是常量，则直接构造常量返回即可。
    - 是变量，则发射对应指令。

17. `FuncCallStmt`
    该方法负责为函数调用语句生成 `IR` 指令。主要逻辑如下：
    + 查找符号表：通过函数名在`scope`符号表中查找对应的函数定义，并将其从基类 `Value` 类型转换为派生类 `Function` 类型，从而获取函数的详细信息。
    + 获取形参列表：通过函数类中的参数迭代器，构造形参列表 `func_params`，为后续的实参类型检查和转换做准备。
    + 递归访问实参：对每个实参节点调用访问方法，返回对应的`latest_value`值（即实参信息），再根据形参的类型，与当前实参的类型进行匹配：
        +  如果形参为 `FLOAT_T` 而实参为 `INT32_T`，则将实参类型转换为浮点数。
        +  如果形参为 `INT32_T` 而实参为 `FLOAT_T`，则将实参类型转换为整数。
        +  如果类型一致，则直接将实参加入实参列表 `true_params`。
    + 生成调用指令：在完成类型匹配和转换后，使用函数指针和实参列表调用 `create_call` 方法生成函数调用的 `IR` 指令，结果更新到 `latest_value` 中以供后续使用。

18. `IfStmt`
    该方法负责为 `if` 语句生成 `IR`（中间表示）指令，主要逻辑如下：

    + 保存和恢复全局变量：
    因为 `if` 语句可能嵌套，为了保证全局变量（如 `TrueBB` 和 `FalseBB`）的一致性，进入该方法时将全局变量暂存，退出时恢复。
    + 创建基本块：
    为 `if` 的 `True`分支、`False` 分支（以及可能的 `NextBB`）创建对应的基本块，用于分支跳转控制。
    + 处理条件表达式：递归访问条件表达式 `cond_exp`，生成对应的值 `latest_value`。如果条件表达式的类型不是布尔值 (`INT1_T`)，则根据类型（`INT32_T` 或 `FLOAT_T`）转换为布尔值，通过比较是否等于0得到。
    + 生成分支跳转指令：
    使用 `builder->create_cond_br` 根据条件值生成条件分支跳转指令，将控制流导向 `TrueBB` 或 `FalseBB`。
    + 递归生成 `if` 和 `else` 分支的代码：
    进入 `TrueBB`，递归访问 `if_statement` 子树，生成对应代码。如果当前块没有终止指令（如 `ret`），插入跳转到 `NextBB` 的指令。
    如果存在 `else_statement`，进入 `FalseBB`，递归访问 `else_statement` 子树并生成代码。没有终止指令时，同样插入跳转到 `NextBB` 的指令。
    + 处理 `NextBB` 和清理：
    如果需要 `NextBB`（例如没有 `else` 分支或分支代码未终止），切换到`NextBB`，插入标签以继续后续代码生成。
    如果 `NextBB` 未被使用（例如 `if` 和 `else` 块都以终止指令结束，不可达下一个基本块），则删除无用的 `NextBB`。
    + 恢复全局变量：
    在 `if` 语句处理完毕后，将之前暂存的全局变量恢复，确保后续代码生成不受影响。
19.  `WhileStmt`
    该方法用于为 `while` 循环生成 `IR`（中间表示）指令，主要逻辑如下：
     + 保存和恢复全局变量：
    因为 `while` 循环可能嵌套，为避免变量冲突，进入该方法时将全局变量（`CondBB、TrueBB、FalseBB、NextBB`）暂存，退出时恢复。
      + 创建基本块：
         + 创建与 `while` 循环相关的基本块：
        `CondBB`：用于条件判断。
        `TrueBB`：表示循环体的基本块。
        `FalseBB`：条件为假时跳转的基本块，也作为循环的结束块。
         + 将 `FalseBB` 设为 `NextBB`，表示循环后续代码的入口。
     + 条件判断跳转：
    先跳转到 `CondBB`，设置插入点为 `CondBB`，递归访问条件表达式 `cond_exp`。
    将条件表达式的结果 `latest_value` 转换为布尔值（`INT1_T`）：
    如果是整型（`INT32_T`），通过比较不等于零得到布尔值。
    如果是浮点型（`FLOAT_T`），通过浮点比较不等于零得到布尔值。
    生成条件分支指令，跳转到 `TrueBB`（条件为真）或 `FalseBB`（条件为假）。
     + 循环体处理：
    设置插入点为 `TrueBB`，递归访问循环体 `stmt`，生成循环体的 `IR`。
    检查 `TrueBB` 是否已有终止指令（如 `ret`），如果没有，生成跳转回 `CondBB` 的指令以重复条件检查。
     + 循环结束处理：
    设置插入点为 `NextBB`，作为循环后代码的开始点。
     + 恢复全局变量：
    在 `while` 处理完毕后，将之前暂存的全局变量恢复，确保后续代码生成不受影响。
20.   `BreakStmt`
    全局变量`CondBB`就是当前`while`循环内的`Cond`基本块，直接发射跳转指令即可。
21.   `ContinueStmt`
    全局变量`FalseBB`就是当前`while`循环内的`false`基本块，直接发射跳转指令即可。
##  实验难点及解决方案
1. `FuncDef`的难点
   
   + 函数的返回类型可能是 void、int 或 float，根据返回类型的不同，生成 IR 代码时需要选择不同的返回指令。
   + 需要在 FuncDef 的实现过程中确保函数的返回块（retBB）正确创建，并根据函数的返回类型决定是生成 void 返回指令，还是返回实际的返回值。
     解决方案：
     + 在 FuncDef 中，首先获取返回类型并为其分配内存空间（如果返回类型不是 void）。
     + 在函数体中，检查函数是否有返回值，如果没有，则根据返回类型补充默认的返回值（如 0 或 0.0）。
     + 通过 builder->create_ret() 生成返回指令，将返回值从 retAlloc 中加载并返回。
   + 如果函数体内没有显式的返回值（例如 main 函数），我们需要在生成的 IR 代码中自动补充返回值。尤其是对于 main 函数，应该返回一个默认值 0
      解决方案：
     + 在 FuncDef 中检查是否有返回值（通过 func_ret 标志），如果没有，则根据函数的返回类型补充返回值。
     + 对于 main 函数，默认补充返回 0，而对于其他函数，若返回类型为 void，则直接返回，若返回类型为 int 或 float，则返回 0 或 0.0。
   
2. 短路计算的难点
   + 控制流的改变： 短路计算依赖于控制流的改变，这意味着我们不仅需要生成正常的操作指令，还要处理如何跳过后续的计算。尤其是在条件表达式中，当一个操作数已经足够决定最终的结果时，后续部分的计算就会被跳过。
     + 对于 &&（逻辑与）运算，如果第一个操作数是 false，那么整个表达式无论第二个操作数是什么，最终结果都会是 false，因此第二个操作数的计算不再必要。
     + 对于 ||（逻辑或）运算，如果第一个操作数是 true，那么整个表达式无论第二个操作数是什么，最终结果都会是 true，因此第二个操作数的计算也不再必要。
   + IR中的控制流结构： 在LLVM IR中，需要使用 br（跳转）指令来实现控制流的跳转。为了实现短路计算，生成器需要根据表达式的逻辑结构插入条件跳转指令，这往往导致更复杂的基本块结构。每个条件操作都需要进行跳转，并根据结果决定是否跳过剩余的操作。
   + 解决方案：
     + 插入条件跳转指令： 通过插入 cond_br（条件跳转）指令，可以根据条件的计算结果决定是否跳过后续表达式的计算。例如，对于 a && b，首先计算 a，如果 a 为 false，就跳转到 false 分支，跳过 b 的计算。
     + 基本块的分割： 利用LLVM IR的基本块来分割控制流。每个短路计算的分支都需要一个新的基本块，控制流可以根据条件表达式的结果跳转到不同的块，从而避免不必要的计算。
     + 类型转换和比较的合理使用： 在处理短路计算时，需要确保比较结果的类型一致，例如，若逻辑表达式中的条件是整数，则需要将其转换为布尔值（int1 类型）来进行逻辑比较。如果类型不一致，可能会影响跳转逻辑的正确性。例如，在处理 a && b 时，我们需要生成一个基本块来评估 a，如果 a 为 false，则直接跳转到整个表达式为 false 的结果；否则，继续评估 b，并根据 b 的结果决定表达式的最终值。
   
   3. vardef与LVal部分难点

​		vardef和LVal中涉及到较多的类型判断和类型转换， 另外变量初始化的形式较多， 因此这部分出现的问题也比较多。 但是由于本次实验不考虑多维数组， 所以还是大大降低了实验的难度。

​		解决方案：我们分层次地依次解决了不同位置的变量初始化， 通过大量测例找出遗漏情况并完善代码。解决了较细碎的问题。

## 实验总结

+ (殷一鸣)本次实验我负责了Funcdef等和后面耦合比较多的模块，感觉难点在于大致理解后面其他组员写的函数的大致流程，尤其是fn，latest_value等后面经常用到的全局变量的定义及用法，也多亏组员比较详细的注释，写的还算顺利，通过本次实验，我的合作coding的能力有了一些提升。
+ （储溦）通过本次实验，我对`LLVM IR`的生成流程和编译器后端的工作有了更深入的理解。我学会了如何将高级语言的抽象语法转换为低级的中间表示，这对我日后学习和理解编译器架构以及性能优化具有重要意义。
+ (郭泽) 通过本次实验， 我们深入理解了LLVM IR 的生成流程和编译原理， 同时对c++的动态类型， 智能指针等有了更深的理解。 在小组合作分工的过程中， 我们也锻炼了分组协作的能力， 锻炼了我们多人合作共享的模式能力。
## 实验反馈
+ （殷一鸣）助教可以推荐一下实验分工，因为一些函数是通过全局变量进行耦合的，最好能由一个人负责，但一开始的时候预知不了，所以可能导致组员进度间的互相依赖。 
+ （储溦）无
+   (郭泽)  无
## 组间交流
基本是线下面对面交流，提高开发效率。
