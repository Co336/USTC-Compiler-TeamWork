# 实验报告

学号1 姓名1 学号2 姓名2 学号3 姓名3
## 说明
问题回答部分由每个组员自己编写，剩余的部分由小组成员共同编写。
## 问题回答

## 实验设计
### 每个节点的`Visit`方法设计
1. `InitVal`

2. `FuncDef`

3. `FuncFParamList`

4. `FuncParam`

5. `VarDef`

   ​	这一部分处理变量的初始化。 我们分层次进行这一节点的设计。 首先在`SysYFIR`中， 全局变量和局部变量使用不同的分配空间的方式和初始化的方式， 所以我们先讨论是否是全局变量。 然后对于每一个变量， 我们讨论其是不是数组， 是否初始化以及其变量类型。 根据不同的变量类型分别完成对不同变量的空间分配和初始化。

6. `LVal`

   ​	这一部分处理表达式(`expr`)中出现的标识符以及赋值函数中出现的左值标识符。 因为在赋值函数`Assign`中， 访问`target(LVal)`节点期望得到的信息是变量的指针(便于存储)， 而在普通的表达式节点(`expr`)中期望得到的是变量的值， 因此我们需要另设变量告诉`LVal`我们需要的是什么值。 我们设置全局布尔型变量 `LVal_retValue`和`LVal_retPtr`， 用来告诉`LVal`我们需要获取的是指针还是数值， 在每一次访问`expr`节点前， 我们都对全局变量进行设置， 以保证两个变量其一为0。

   ​	值得注意的是， 我们处理数组时， 由于函数可以接收数组指针作为变量， 所以除了数组类型`ArrayType`以外， 我们还有可能接收到指针类型`PointerType`， 对这两种类型的处理在`task2`中进行过讨论。 `PointerType`我们只需要设置偏移量， 而`ArrayType`我们需要前置一个`CONST_INT(0)` 来进入数组第一维， 再利用其偏移量得到我们想要的数组下标。

7. `AssignStmt`

   ​	这一部分处理赋值语句。 由于`LVal`帮我们做了大部分内容， 所以这一部分设计相对简单。 需要注意的点是不同类型的值之间进行相互赋值时要考虑到类型的转换。`SysYF`中赋值语句右侧是不出现布尔型表达式的， 即使考虑初始化， 等号右侧也不会有布尔表达式， 所以我们相应也没有编写这种情况对应的代码。

8. `Literal`

   ​	这一部分处理字面量。 这一部分代码由框架给出， 我们不作赘述。 由于组员使用全局变量进行节点间值的传递， 因此我们将`visitee`的返回方式改为全局变量返回。

   ​	但是有一点需要注意的是， 对于定义成浮点类型的整数， 如 `fload c = 4`;， 字面量只能读出4为`CONST_INT(4)`， 需要`vardef`进行自行的判断类型和赋值的类型是否匹配， 如果不匹配， 必须进行类型的更改。

9. `ReturnStmt`

   ​	这一部分处理函数返回。 部分代码已给出， 但我们还是作了较多的修改。 为了`main`函数默认返回0， 我们引入新的全局变量告诉`funcdef` 当前函数是否具有了返回声明。 然后我们作统一的返回出口， 所有`return`语句跳到统一的返回出口进行返回。

10. `BlockStmt`

    ​	这一部分处理函数体等(包括`if`， `while`， `{}`的函数体)。 代码框架已给出(我记得好像是给的)， 我们没有作修改处理。

11. `EmptyStmt`
    直接置空不管即可，因为不会产生中间代码。

12. `ExprStmt`
    递归访问其中的`exp`即可，不需要发射指令，会在具体的表达式节点发送。

13. `UnaryCondExpr`

    该函数负责为单目条件运算符 `NOT` 生成 `IR` 指令。在实现中，通过暂存当前的 `TrueBB` 和 `FalseBB`（表示条件为真或假的基本块）状态后，将两者交换，以反映 `NOT` 的逻辑反转特性。递归访问子表达式后，根据其结果类型（如 `INT1_T`, `INT32_T`, 或 `FLOAT_T`），生成对应的比较指令(注意这里是`eq`指令而不是`ne`指令)，判断子表达式值是否为零，从而实现逻辑取反。最后，恢复原先的 `TrueBB` 和 `FalseBB` 状态，以保证递归访问对全局状态的影响被消除。这种处理方式既保证了短路计算的正确性，也维护了全局环境的完整性。

14. `BinaryCondExpr`

    该函数实现了对二目条件表达式的 `IR` 生成逻辑，支持逻辑运算符（`AND` 和 `OR`）以及关系运算符（如等于、不等于、大于等于等）的处理。对于逻辑运算符 `AND` 和 `OR`，函数实现了短路计算机制。首先对于`OR`，如果左操作数为真，可以直接跳转到整体条件的 `TrueBB`（即全局的`TrueBB`），无需计算右操作数；否则进入右操作数处理分支。函数通过为左操作数创建一个 `RightBB` 局部基本块表示右操作数的入口点，同时保存并恢复 `FalseBB`（因为对于左操作数而言，其错误分支不是全局整个条件表达式的错误分支），以确保逻辑正确性。同样，对于 `AND`，如果左操作数为假，可以直接跳转到整体条件的 `FalseBB`；否则进入右操作数处理分支。类似地，为右操作数创建 `RightBB` 局部基本块，保存并恢复 `TrueBB`。在访问操作数后，函数将值统一转换为布尔类型 (`INT1_T`) 并生成相应的条件跳转指令。对于关系运算符，函数会依次处理左右操作数，并通过类型转换确保两者类型一致（可能涉及 `INT1_T、INT32_T、FLOAT_T` 等）。然后根据运算符类型（如`EQ`、`NEQ`、`GT` 等）生成对应的比较指令，比较结果被更新给 `latest_value` ，用于表示全局最近处理的表达式的值，以便后续的控制流读取处理。

15. `BinaryExpr`

    这里分为两种情况，因为我们实现了对常量的编译优化。

    - 左右操作数都是常量

    - 存在变量操作数

16. `UnaryExpr`

    这里可能出现的算符是`+`和`-`，代表正和负，

17. `FuncCallStmt`

    该方法负责为函数调用语句生成 `IR` 指令。主要逻辑如下：

    + 查找符号表：通过函数名在`scope`符号表中查找对应的函数定义，并将其从基类 `Value` 类型转换为派生类 `Function` 类型，从而获取函数的详细信息。

    + 获取形参列表：通过函数类中的参数迭代器，构造形参列表 `func_params`，为后续的实参类型检查和转换做准备。

    + 递归访问实参：对每个实参节点调用访问方法，返回对应的`latest_value`值（即实参信息），再根据形参的类型，与当前实参的类型进行匹配：

      ​    + 如果形参为 `FLOAT_T` 而实参为 `INT32_T`，则将实参类型转换为浮点数。

      ​    + 如果形参为 `INT32_T` 而实参为 `FLOAT_T`，则将实参类型转换为整数。

      ​    + 如果类型一致，则直接将实参加入实参列表 `true_params`。

    + 生成调用指令：在完成类型匹配和转换后，使用函数指针和实参列表调用 `create_call` 方法生成函数调用的 `IR` 指令，结果更新到 `latest_value` 中以供后续使用。

18. `IfStmt`

19. `WhileStmt`

20. `BreakStmt`

21. `ContinueStmt`
### Add Others If You Need
## 实验难点及解决方案

## 实验总结

## 实验反馈

## 组间交流
